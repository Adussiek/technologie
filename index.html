    <!DOCTYPE html>
    <html lang="pl">
    <head>
        <meta charset="UTF-8">
        <title>Projekt Gas Bank</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
        <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
        <link rel="stylesheet" href="style.css">
    </head>

    <body>

    <div id="sidebar">
        <h3>ğŸ“ Punkty trasyğŸ“</h3>
        <div id="pins"></div>
        <div id="summary"></div>
    </div>

    <div id="main">
        <div id="topbar">
            <input id="fromInput" placeholder="SkÄ…d" oninput="autocompleteFrom()">
            <div id="fromResults" class="autocomplete-results"></div>

            <input id="toInput" placeholder="DokÄ…d" oninput="autocompleteTo()">
            <div id="toResults" class="autocomplete-results"></div>

            <select id="fuelSelect">
                <option value="pb95">PB95</option>
                <option value="diesel">ON</option>
                <option value="lpg">LPG</option>
            </select>

            <button onclick="calculate()">Trasa</button>
            <button onclick="resetAll()">Reset</button>
            <button id="toggleTheme" onclick="toggleTheme()">ğŸŒ™ / â˜€ï¸</button>

            <label>
                PasaÅ¼erowie:
                <input id="passengers" type="number" value="1" min="1" class="passenger-input">
            </label>
        </div>

        <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        const FUELS={pb95:{burn:7.5,price:6.5}, diesel:{burn:6.8,price:6.7}, lpg:{burn:9.0,price:3.2}};
        const TOMTOM_KEY="MxnSy7KKOqai6ZHcI8jy1RTY2xX0699s";
        const map=L.map('map').setView([52.1,19.4],6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

        let points=[], markers=[], routeLayer, infoMarker;

        // --- AUTOCOMPLETE ---
        async function autocompleteFrom(){
          if(fromInput.value.length<2){fromResults.innerHTML=""; return;}
          const d=await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(fromInput.value)}`).then(r=>r.json());
          fromResults.innerHTML="";
          d.forEach(item=>{
            const div=document.createElement("div");
            div.textContent=item.display_name;
            div.onclick=()=>{fromInput.value=item.display_name; fromInput.dataset.lat=item.lat; fromInput.dataset.lon=item.lon; fromResults.innerHTML="";}
            fromResults.appendChild(div);
          });
        }
        async function autocompleteTo(){
          if(toInput.value.length<2){toResults.innerHTML=""; return;}
          const d=await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(toInput.value)}`).then(r=>r.json());
          toResults.innerHTML="";
          d.forEach(item=>{
            const div=document.createElement("div");
            div.textContent=item.display_name;
            div.onclick=()=>{toInput.value=item.display_name; toInput.dataset.lat=item.lat; toInput.dataset.lon=item.lon; toResults.innerHTML="";}
            toResults.appendChild(div);
          });
        }

        // --- TEMPERATURE ---
        async function getTemperature(lat, lon){
          try {
            const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`);
            const data = await res.json();
            if(data.current_weather && typeof data.current_weather.temperature === "number") return data.current_weather.temperature;
          } catch(e) { console.warn("Weather API error",e); }
          return 15;
        }

        // --- TRAFFIC ---
        async function getTrafficRatio(lat,lon){
          try{
            const data=await fetch(`https://api.tomtom.com/traffic/services/4/flowSegmentData/json?point=${lat},${lon}&unit=KMPH&key=${TOMTOM_KEY}`).then(r=>r.json());
            return data.flowSegmentData.currentSpeed/data.flowSegmentData.freeFlowSpeed;
          }catch(e){return 1;}
        }

        // --- DRAW ROUTE ---
        async function drawRoute(){
          if(points.length<2) return;
          if(routeLayer) map.removeLayer(routeLayer);
          if(infoMarker) map.removeLayer(infoMarker);
          markers.forEach(m=>map.removeLayer(m));
          markers=[];

          const coords=points.map(p=>`${p.lon},${p.lat}`).join(";");
          const r=await fetch(`https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`).then(r=>r.json());
          const route=r.routes[0];
          const coordsLatLng = route.geometry.coordinates.map(c=>[c[1],c[0]]);
          const fuel=FUELS[fuelSelect.value];
          const passengers = Math.max(1, parseInt(document.getElementById("passengers").value)||1);

          // Oblicz caÅ‚kowity koszt trasy uwzglÄ™dniajÄ…c Å›redniÄ… temperaturÄ™ wszystkich punktÃ³w
          let temps=[], totalTraffic=0;
          for(const p of points){
            const t = await getTemperature(p.lat,p.lon);
            const traffic = await getTrafficRatio(p.lat,p.lon);
            p.temp = t;
            p.trafficRatio = traffic;
            temps.push(t);
            totalTraffic += traffic;
          }
          const avgTemp = temps.reduce((a,b)=>a+b,0)/temps.length;
          let burn = fuel.burn;
          if(avgTemp<10) burn*=1.1;
          else if(avgTemp<20) burn*=1.05;
          else if(avgTemp>30) burn*=1.02;

          const totalKm = route.distance/1000;
          const totalLiters = totalKm*burn/100;
          const totalCost = totalLiters*fuel.price;



          // Marker punkty i popupy
          markers=[];
          for(const p of points){
            const mColor = p.trafficRatio>0.8?'green':p.trafficRatio>0.5?'orange':'red';
            const marker = L.circleMarker([p.lat,p.lon],{radius:8, fillColor:mColor, color:"#000", weight:1, fillOpacity:0.8}).addTo(map);
            marker.bindPopup(`
              <b>${p.name}</b><br>
              ğŸŒ¡ Temp: ${p.temp.toFixed(1)} Â°C<br>
              ğŸš¦ Ruch: ${p.trafficRatio>0.8?'ğŸŸ¢ pÅ‚ynny':p.trafficRatio>0.5?'ğŸŸ  Å›redni':'ğŸ”´ korek'}
            `);
            marker.on("dragend", e=>{p.lat=e.target.getLatLng().lat; p.lon=e.target.getLatLng().lng; drawRoute();});
            markers.push(marker);
          }

          routeLayer=L.geoJSON(route.geometry,{style:{color:"#007bff",weight:5}}).addTo(map);
          map.fitBounds(routeLayer.getBounds());

          renderPins(totalKm, totalLiters, totalCost, passengers, totalTraffic/points.length);
        }

        // --- SIDEBAR ---
        function renderPins(totalKm,totalLiters,totalCost,passengers,avgTraffic){
          pins.innerHTML="";
          points.forEach((p,i)=>{
            const trafficColor = p.trafficRatio>0.8?'ğŸŸ¢':p.trafficRatio>0.5?'ğŸŸ ':'ğŸ”´';
            pins.innerHTML += `
              <div class="pin">
                <b>${i==0?"ğŸŸ¢ START":i==points.length-1?"ğŸ”´ META":"ğŸ“ PUNKT"}</b><br>
                ${p.name}<br>
                ğŸŒ¡ Temp: ${p.temp.toFixed(1)} Â°C<br>
                ğŸš¦ ${trafficColor}<br>
                <button onclick="movePoint(${i},-1)">â¬†</button>
                <button onclick="movePoint(${i},1)">â¬‡</button>
                <button onclick="removePoint(${i})">âŒ</button>
              </div>
            `;
          });
          summary.innerHTML=`<b>CaÅ‚kowita trasa:</b> ${totalKm.toFixed(1)} km<br>
        ğŸŒ¡ Åšrednia temp: ${points.reduce((a,b)=>a+b.temp,0)/points.length.toFixed(1)} Â°C<br>
        ğŸš¦ Åšredni ruch: ${avgTraffic>0.8?'ğŸŸ¢ pÅ‚ynny':avgTraffic>0.5?'ğŸŸ  Å›redni':'ğŸ”´ korek'}<br>
        â›½ CaÅ‚kowite spalanie: ${totalLiters.toFixed(2)} l<br>
        ğŸ’° Koszt/os: ${(totalCost/passengers).toFixed(2)} zÅ‚`;
        }

        // --- MOVE / REMOVE ---
        function movePoint(i,dir){const j=i+dir;if(j<0||j>=points.length) return; [points[i],points[j]]=[points[j],points[i]]; drawRoute();}
        function removePoint(i){points.splice(i,1); drawRoute();}
        function clearRoute(){if(routeLayer) map.removeLayer(routeLayer); if(infoMarker) map.removeLayer(infoMarker); markers.forEach(m=>map.removeLayer(m)); markers=[];}

        // --- CALCULATE / RESET ---
        async function calculate(){
          points=[];
          if(fromInput.dataset.lat && fromInput.dataset.lon && toInput.dataset.lat && toInput.dataset.lon){
            points.push({lat:+fromInput.dataset.lat, lon:+fromInput.dataset.lon, name: fromInput.value});
            points.push({lat:+toInput.dataset.lat, lon:+toInput.dataset.lon, name: toInput.value});
            drawRoute();
          } else alert("Wybierz dokÅ‚adny adres z listy!");
        }
        function resetAll(){points=[]; clearRoute(); fromInput.value=""; fromInput.dataset.lat=""; fromInput.dataset.lon=""; toInput.value=""; toInput.dataset.lat=""; toInput.dataset.lon=""; pins.innerHTML=""; summary.innerHTML=""; map.setView([52.1,19.4],6);}
        function toggleTheme(){document.body.classList.toggle('dark-mode');}

        // --- DWUKLIK DO DODAWANIA PUNKTU ---
        map.on("dblclick", async e=>{
          const name=await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${e.latlng.lat}&lon=${e.latlng.lng}`).then(r=>r.json()).then(d=>d.display_name||"Punkt");
          points.splice(points.length-1,0,{lat:e.latlng.lat, lon:e.latlng.lng, name});
          drawRoute();
        });
    </script>


    </body>
    </html>